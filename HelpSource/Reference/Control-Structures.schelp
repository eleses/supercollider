title::Control Structures
summary:: flow control
categories:: Language
related:: Classes/Boolean

Control structures in SuperCollider are implemented via message sends. Here are a few of those available.
See link::Reference/Syntax-Shortcuts:: for the various ways expressions can be written.

section:: Basic Control Structures

method:: if

Conditional execution is implemented via the code::if:: message. The code::if:: message is sent to an expression which must return a link::Classes/Boolean:: value.
In addition it takes two arguments: a function to execute if the expression is true and another optional function to execute if the expression is false. The code::if:: message returns the value of the function which is executed. If the falseFunc is not present and the expression is false then the result of the if message is nil.

discussion::
Syntax
code::
if (expr, trueFunc, falseFunc);
::
--or, by pulling the functions out of the parentheses--
code::
if (expr) {trueFuncBody} {falseFuncBody};
::
--or, as an explicit message sent to the condition object code::expr::--
code::
expr.if (trueFunc, falseFunc);
::

note::
The functions can be pulled out of the parentheses, leaving parentheses only around the condition, allowing one to write code more reminiscent of the C-style programming languages. However, this is valid syntax in SuperCollider only if the functions are given "inline" as function literals, i.e. surrounded by braces. This rule applies to all other control structures discussed within this document. It is a result of the general mechanism of how "extra" function literals, appearing after parentheses, are passed as additional arguments to method calls (messages).
::

As in functional programming languages, the if-expression itself has a value. The value of the if-expression is the value of the branch-function executed. The second-branch function can be omitted, in which case it evaluates as code::nil::. (This is relevant if the condition is false.)

Syntax examples:
code::
(
if ( [false, true].choose,				// Boolean expression (chooses one at random)
	{ "expression was true".postln },	// true function
	{ "expression was false".postln }	// false function
)
)
::
The same control logic as above, but "pulling out" the functions and thus closer to C-language style:
code::
(
if ( [false, true].choose ) {
	"expression was true".postln
} {
	"expression was false".postln
}
)
::
As noted earlier, pulling out functions works only for function literals:
code::
(
var f = { "expression was true".postln };
var g = { "expression was false".postln };

if ( [false, true].choose, f, g );		// is a valid expression
[false, true].choose.if( f, g );		// ibid.
)
::
In contrast, attempting to pass expressions that are not function literals after the parentheses results in a syntax error:
code::
if ( [false, true].choose ) f g;		// is a syntax error
if ( [false, true].choose ) f;			// ibid.
::

If-expression value examples:
code::
(
var a = 1, z;
z = if (a < 5, { 100 },{ 200 });
z.postln; // 100
)
::
Omitting the second branch-function has no effect if the condition-expression is true.
code::
(
var x;
if (x.isNil, { x = 99 });
x.postln; // 99
)
::
However, if the 2nd branch-function is omitted and the condition-expression is false, then the if-expression evaluates to nil.
code::
(
var x = 11, z;
z = if (x > 99, { x = \guess });
z.postln; // z is nil because there was no 2nd branch and expr was false
)
::
Omitting both branches is syntactically valid, the condition is still evaluated, but the if-expression evaluates to nil
code::
(
var z = if (true.postln);
z.postln;
)
::


method:: while

The code::while:: message implements conditional execution of a loop. If the code::testFunc:: answers true when evaluated, then the code::bodyFunc:: is evaluated and the process is repeated. Once the code::testFunc:: returns false, the loop terminates.

The value of the while-expression itself depends whether the code::while:: is optimized (inlined) by the compiler or not. If it is inlined/optimized, the while-expression evaluates to nil. Otherwise it evaluates to the receiver code::testFunc::.

discussion::
Syntax
code::
while ( testFunc, bodyFunc );
::
--or (pulling out both functions from parentheses)--
code::
while { testFuncBody } { bodyFuncBody };
::
--or--
code::
testFunc.while( bodyFunc );
::

Examples
code::
(
var i = 0;
while ( { i < 5 }, { i = i + 1; "boing".postln });
)
::
The same, but omitting parentheses around the functions:
code::
(
var i = 0;
while { i < 5 } { i = i + 1; "boing".postln };
)
::
As with code::if::, only the former syntax, with functions inside parentheses can be used for non-literal functions
code::
(
var i = 0;
var c = { i < 5 };
var b = { i = i + 1; "boing".postln };
z = while (c, b);   // valid
z = c.while(b);	    // valid
)
::
In contrast, these are syntax errors:
code::
while c b;			// syntax error
while { i < 5 } b;	// ibid.
c.while b;	        // ibid.
::

Since code::while:: only takes one additional argument besides its receiver, it can be written as an infix binary operator too:
code::.
(
var i = 0;
var c = { i < 5 };
var b = { i = i + 1; "boing".postln };
c while: b;	        // valid.

{ i < 5 } while: { i = i + 1; "boing".postln };
)
::


The value of an optimized/inlined while expressions is always nil.

code::
(
var i = 0, z;
z = while ( { i < 5 }, { i = i + 1; "boing".postln });
z.postln; // nil
)
::
However an unoptimized while-expression evaluates to its code::testFunc:: object and not to its code::value::, even though it is the code::value:: of the latter that controls the iteration process.
code::
(
var i = 0;
var c = { i < 5 };
z = while (c, { i = i + 1; "boing".postln });
z === c; // true
)
::
This is still true even if just the second function is not a function literal.
code::
(
var i = 0;
var b = { i = i + 1; "boing".postln };
z = while ({ i < 5 }, b);
z.postln // a Function
)
::

While expressions are optimized by the compiler if both of the following are met:
list::
## code::testFunc:: and the code::bodyFunc:: are passed as function literals to code::while::, and
## the bodies of these two functions do not contain variable declarations.
::


method:: for

The for message implements iteration over an integer series from a starting value to an end value stepping by one each time. A function is evaluated each iteration and is passed the iterated numeric value as an argument.

The value of the for-expression itself is the (receiver) code::startValue::.

discussion::
Syntax
code::
for ( startValue, endValue, function )
::
--or--
code::
for ( startValue, endValue ) { functionBody }
::
--or--
code::
startValue.for ( endValue, function )
::

Example:
code::
for (3, 7, { arg i; i.postln }); // prints values 3 through 7
::
The same example, but pulling out the function from the parentheses:
code::
for (3, 7) { arg i; i.postln };
::
If the function is not a function literal, only the former syntax is valid:
code::
(
var b = { arg i; i.postln };
for (3, 7, b); // valid
)
// whereas
for (3, 7) b; // syntax error
::

The receiver-based syntax is also a valid for code::for::, but probably rather confusing in this application:

code::
3.for(7, { arg i; i.postln });
3.for(7) { arg i; i.postln };
::


method:: forBy

The forBy selector implements iteration over an integer series with a variable step size. A function is evaluated each iteration and is passed the iterated numeric value as an argument.

discussion::
Syntax
code::
forBy ( startValue, endValue, stepValue, function );
::
--or--
code::
forBy ( startValue, endValue, stepValue ) { functionBody };
::
--or--
code::
startValue.forBy ( endValue, stepValue, function );
::

Examples
code::
forBy (0, 8, 2, { arg i; i.postln }); // prints values 0 through 8 by 2's

forBy (0, 8, 2) { arg i; i.postln };  // ibid
::


method:: do

Do is used to iterate over a link::Classes/Collection::. Positive Integers also respond to code::do:: by iterating from zero up to their value. Collections iterate, calling the function for each object they contain. Other kinds of Objects respond to do by passing themselves to the function one time. The function is called with two arguments, the item, and an iteration counter.

discussion::
Syntax
code::
do ( collection, function )
::
--or--
code::
do ( collection ) { functionBody }
::
--or--
code::
collection.do(function)
::
--or--
code::
collection.do { functionBody }
::

Basic syntax examples:
code::
do(5, { arg item; item.postln }); // iterates from zero to four
do(5) { arg item; item.postln };  // ibid, no parentheses around the function
5.do({ arg item; item.postln });  // making the receiver more explicit
5.do { arg item; item.postln };   // ibid, and also no parentheses at all
::

Omitting parentheses is not possible if the function is not a literal

code::
(
var f = { arg item; item.postln };
5.do(f) // valid
)
// but
5.do f  // syntax error
::

However, since code::do:: only takes one argument besides its (collection) receiver, the example immediately above can also be written using code::do::: as a binary operator:
code::
(
var f = { arg item; item.postln };
5 do: f // valid
)
::

Additional examples:
code::
[ 1, 2, "abc", (3@4) ].do({ arg item, i; [i, item].postln; });

"you".do({ arg item; item.postln }); // a String is a collection of characters

'they'.do({ arg item; item.postln }); // a Symbol is a singular item

(8..20).do({ arg item; item.postln }); // iterates from eight to twenty

(8,10..20).do({ arg item; item.postln }); // iterates from eight to twenty, with stepsize two

Routine({ var i=10; while { i > 0 } { i.yield; i = i - 5.0.rand } }).do({ arg item; item.postln });
::

Note:: The syntax code::(8..20).do:: uses an optimization to avoid generating an array that is used only for iteration (but which would be discarded thereafter). The return value of code:: (8..20).do({ |item| item.postln }) :: is 8, the starting value.
code::
(8..20) do: { |item| item.postln } // is not optimized, and returns the array.
::
::

method:: switch

Object implements a switch method which allows for conditional evaluation with multiple cases. These are implemented as pairs of test objects (tested using if this == test.value) and corresponding functions to be evaluated if true.
The switch statement will be inlined if the test objects are all Floats, Integers, Symbols, Chars, nil, false, true and if the functions have no variable or argument declarations. The inlined switch uses a hash lookup (which is faster than nested if statements), so it should be very fast and scale to any number of clauses.

discussion::
Syntax
code::
switch (value,
        testvalue1, trueFunction1,
        testvalue2, trueFunction2,
        ...
        testvalueN, trueFunctionN,
        defaultFunction);
::

Examples
code::
(
var x=0; //also try 1
switch(x,0,{"hello"}, 1, {"goodbye"})
)

(
var x, z;
z = [0, 1, 1.1, 1.3, 1.5, 2];
switch (z.choose.postln,
	1,   { \no },
	1.1, { \wrong },
	1.3, { \wrong },
	1.5, { \wrong },
	2,   { \wrong },
	0,   { \true }
).postln;
)
::
or:
code::
(
var x, z;
z = [0, 1, 1.1, 1.3, 1.5, 2];
x = switch (z.choose)
	{1}   { \no }
	{1.1} { \wrong }
	{1.3} { \wrong }
	{1.5} { \wrong }
	{2}   { \wrong }
	{0}   { \true };
x.postln;
)
::

method:: case

Function implements a case method which allows for conditional evaluation with multiple cases. Since the receiver represents the first case this can be simply written as pairs of test functions and corresponding functions to be evaluated if true. Case is inlined and is therefore just as efficient as nested if statements.
discussion::
Example
code::
(
var i, x, z;
z = [0, 1, 1.1, 1.3, 1.5, 2];
i = z.choose;
x = case
	{ i == 1 }   { \no }
	{ i == 1.1 } { \wrong }
	{ i == 1.3 } { \wrong }
	{ i == 1.5 } { \wrong }
	{ i == 2 }   { \wrong }
	{ i == 0 }   { \true };
x.postln;
)
::

section:: Breaking from Iterative Control Structures

A general technique for breaking from iterative control structures relies on the caret (code::^::) return from method because it can exit any number of nested non-method scopes. Using this approach in functions (which are not methods) is possible with the help of link::Classes/Function#block::. For example:

code::
(
var z = block {|break|
    100.do {|i|
        i.postln;
        if (i == 7) { break.value(999) }
    };
};
z.postln;
)
::


section:: Other Control Structures

Using Functions, many control structures can be defined like the ones above. In the class link::Classes/Collection#iteration:: there are many more messages defined for iterating over Collections.

section:: Inline Optimization

code::if::, code::while::, code::switch:: and code::case:: expressions are optimized (i.e. inlined) by the compiler if they do not contain variable declarations in the functions and if the receiver (e.g. for code::while:: and code::case::) is a literal function. The optimization plucks the code from the functions and uses a more efficient jump statement:
code::
(
{
	if(6 == 9, {
		"hello".postln;
	},{
		"world".postln;
	})
}.def.dumpByteCodes
)

BYTECODES: (20)
  0   2C 06    PushInt 6
  2   2C 09    PushInt 9
  4   E6       SendSpecialBinaryArithMsg '=='
  5   F8 00 07 JumpIfFalse 7  (15)
  8   41       PushLiteral "hello"
  9   B0       TailCallReturnFromFunction
 10   C1 3A    SendSpecialMsg 'postln'
 12   FC 00 04 JumpFwd 4  (19)
 15   40       PushLiteral "world"
 16   B0       TailCallReturnFromFunction
 17   C1 3A    SendSpecialMsg 'postln'
 19   F2       BlockReturn
-> < closed FunctionDef >
::

Failure to inline due to variable declarations:
code::
(
{
	if(6 == 9, {
		var notHere;
		"hello".postln;
	},{
		"world".postln;
	})
}.def.dumpByteCodes
)

WARNING: FunctionDef contains variable declarations and so will not be inlined.
  in file 'selected text'
  line 4 char 14:

  		var notHere;

  		"hello".postln;
-----------------------------------
BYTECODES: (13)
  0   2C 06    PushInt 6
  2   2C 09    PushInt 9
  4   E6       SendSpecialBinaryArithMsg '=='
  5   04 00    PushLiteralX instance of FunctionDef - closed
  7   04 01    PushLiteralX instance of FunctionDef - closed
  9   B0       TailCallReturnFromFunction
 10   C3 0B    SendSpecialMsg 'if'
 12   F2       BlockReturn
-> < closed FunctionDef >
::

You can switch on and off the above warning (see: link::Classes/LanguageConfig#*postInlineWarnings::)

code::
LanguageConfig.postInlineWarnings_(true) // warn
LanguageConfig.postInlineWarnings_(false) // ignore it.
::

An inlined code::while::

code::
(
{
	var i = 0;
	while ( { i < 5 }, { i = i + 1; "boing".postln });
}.def.dumpByteCodes
)

BYTECODES: (18)
  0   30		 PushTempZeroVar 'i'
  1   2C 05    PushInt 5
  3   E8       SendSpecialBinaryArithMsg '<'
  4   F9 00 0A JumpIfFalsePushNil 10  (17)
  7   30		 PushTempZeroVar 'i'
  8   6B       PushOneAndAdd
  9   80 00    StoreTempVar 'i'
 11   40       PushLiteral "boing"
 12   C1 3A    SendSpecialMsg 'postln'
 14   FD 00 0F JumpBak 15  (0)
 17   F2       BlockReturn
-> < closed FunctionDef >
::

And one that is not inlined:

code::
(
{
	var i = 0, c = { i < 5 };
	while (c, { i = i + 1; "boing".postln });
}.def.dumpByteCodes
)

BYTECODES: (11)
  0   04 00    PushLiteralX instance of FunctionDef in closed FunctionDef
  2   80 01    StoreTempVar 'c'
  4   31		 PushTempZeroVar 'c'
  5   04 01    PushLiteralX instance of FunctionDef in closed FunctionDef
  7   B0       TailCallReturnFromFunction
  8   C2 0C    SendSpecialMsg 'while'
 10   F2       BlockReturn
-> < closed FunctionDef >
::

There is presently no compiler warning flag for this latter kind of inlining-failure problem.
